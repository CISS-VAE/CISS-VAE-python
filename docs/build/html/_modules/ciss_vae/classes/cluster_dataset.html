

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ciss_vae.classes.cluster_dataset &mdash; CISS-VAE 1.0.18 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/styles.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=14ed45bf"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=00122899"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            CISS-VAE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html#quickstart">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vignette.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vignette.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vignette.html#running-the-ciss-vae-model">Running the CISS-VAE Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vignette.html#hyperparameter-tuning-with-optuna">Hyperparameter Tuning with Optuna</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vignette.html#creating-a-clusterdataset-object">Creating a <code class="docutils literal notranslate"><span class="pre">ClusterDataset</span></code> object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vignette.html#saving-and-loading-models">Saving and loading models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../missingness_prop_vignette.html">Using <code class="docutils literal notranslate"><span class="pre">create_missingness_prop_matrix</span></code>: A Complete Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dni_vignette.html">Avoiding imputation undesired data entries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CISS-VAE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ciss_vae.classes.cluster_dataset</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ciss_vae.classes.cluster_dataset</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dataset utilities for clustering-aware masking and normalization.</span>

<span class="sd">This module defines :class:`ClusterDataset`, a PyTorch :class:`torch.utils.data.Dataset`</span>
<span class="sd">that (1) optionally holds out a validation subset of *observed* entries on a</span>
<span class="sd">per-cluster basis, (2) normalizes features using statistics computed on the</span>
<span class="sd">masked training matrix, and (3) exposes tensors required by the CISS-VAE</span>
<span class="sd">training loops: normalized data with missing values filled, cluster labels,</span>
<span class="sd">and binary observation masks.</span>

<span class="sd">Typical usage::</span>

<span class="sd">    ds = ClusterDataset(</span>
<span class="sd">        data=df,                       # (N, P) with NaNs for missing</span>
<span class="sd">        cluster_labels=clusters,       # length-N array-like</span>
<span class="sd">        val_proportion=0.1,            # or per-cluster mapping/sequence</span>
<span class="sd">        replacement_value=0.0,</span>
<span class="sd">        columns_ignore=[&quot;id&quot;]          # columns to exclude from validation masking</span>
<span class="sd">    )</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.utils.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<div class="viewcode-block" id="ClusterDataset">
<a class="viewcode-back" href="../../../_autosummary/ciss_vae.classes.cluster_dataset.ClusterDataset.html#ciss_vae.classes.cluster_dataset.ClusterDataset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ClusterDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dataset that handles cluster-wise masking and normalization for VAE training.</span>

<span class="sd">    This dataset:</span>
<span class="sd">      1. Optionally holds out a validation subset **per cluster** from *observed*</span>
<span class="sd">         (non-NaN) entries according to ``val_proportion``.</span>
<span class="sd">      2. Combines original missingness with validation-held-out entries.</span>
<span class="sd">      3. Normalizes observed values column-wise (mean/std), keeps masks for NaNs,</span>
<span class="sd">         and replaces NaNs (incl. held-out) with ``replacement_value``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : pandas.DataFrame | numpy.ndarray | torch.Tensor</span>
<span class="sd">        Input matrix, shape ``(n_samples, n_features)``. May contain NaNs.</span>
<span class="sd">    cluster_labels : array-like or None</span>
<span class="sd">        Cluster assignment per sample (length ``n_samples``). If ``None``,</span>
<span class="sd">        all rows are assigned to a single cluster ``0``.</span>
<span class="sd">    val_proportion : float | collections.abc.Sequence | collections.abc.Mapping | pandas.Series, default=0.1</span>
<span class="sd">        Per-cluster fraction of **non-missing** entries to hold out for validation.</span>

<span class="sd">        Accepted forms:</span>
<span class="sd">          * **float** in ``[0, 1]``: the same fraction for every cluster.</span>
<span class="sd">          * **Sequence** (length ``#clusters``): aligned to ``sorted(unique(cluster_labels))``.</span>
<span class="sd">          * **Mapping** (e.g. ``{cluster_id: fraction}``) covering **all** clusters.</span>
<span class="sd">          * **pandas.Series** with index = cluster IDs covering **all** clusters.</span>
<span class="sd">    replacement_value : float, default=0</span>
<span class="sd">        Value to fill missing/held-out entries in ``self.data`` after masking.</span>
<span class="sd">    columns_ignore : list[str | int] or None, default=None</span>
<span class="sd">        Columns to exclude from validation masking (names for DataFrame, indices otherwise).</span>
<span class="sd">    imputable : pandas.DataFrame | numpy.ndarray | torch.Tensor</span>
<span class="sd">        Matrix showing which data entries to exclude from imputation (0 for impute, 1 for exclude from imputation), shape ``(n_samples, n_features)``.</span>
<span class="sd">        Should be same shape as ``data``. </span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    raw_data : torch.FloatTensor</span>
<span class="sd">        Original data converted to float tensor (NaNs preserved).</span>
<span class="sd">    data : torch.FloatTensor</span>
<span class="sd">        Normalized data with NaNs replaced by ``replacement_value``.</span>
<span class="sd">    masks : torch.BoolTensor</span>
<span class="sd">        Boolean mask where ``True`` marks observed (non-NaN) entries **before** replacement.</span>
<span class="sd">    val_data : torch.FloatTensor</span>
<span class="sd">        Tensor containing **only** validation-held-out values (others are NaN).</span>
<span class="sd">    cluster_labels : torch.LongTensor</span>
<span class="sd">        Cluster ID for each row, shape ``(n_samples,)``.</span>
<span class="sd">    indices : torch.LongTensor</span>
<span class="sd">        Original row indices (from DataFrame index or ``arange`` for arrays/tensors).</span>
<span class="sd">    feature_names : list[str]</span>
<span class="sd">        Column names (from DataFrame) or synthetic names (``V1``, ``V2``, ...).</span>
<span class="sd">    n_clusters : int</span>
<span class="sd">        Number of unique clusters discovered from ``cluster_labels``.</span>
<span class="sd">    shape : tuple[int, int]</span>
<span class="sd">        Shape of ``self.data`` (``n_samples``, ``n_features``).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``data`` or ``cluster_labels`` are of unsupported types; or if</span>
<span class="sd">        ``val_proportion`` is not a float/sequence/mapping/Series.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any provided proportion is outside ``[0, 1]``; or a sequence/mapping/Series</span>
<span class="sd">        omits required clusters; or a sequence length does not match the number</span>
<span class="sd">        of clusters.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Normalization uses column-wise mean/std on the **current observed** values</span>
<span class="sd">      after validation masking; zero stds are set to 1 to avoid division by zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ClusterDataset.__init__">
<a class="viewcode-back" href="../../../_autosummary/ciss_vae.classes.cluster_dataset.ClusterDataset.html#ciss_vae.classes.cluster_dataset.ClusterDataset.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">val_proportion</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">replacement_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">columns_ignore</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">imputable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">val_seed</span> <span class="o">=</span> <span class="mi">42</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the dataset, apply per-cluster validation masking, and normalize.</span>
<span class="sd">        </span>
<span class="sd">        Steps:</span>
<span class="sd">        1. Convert inputs to tensors; preserve indices/column names if a DataFrame.</span>
<span class="sd">        2. Resolve per-cluster validation proportions from ``val_proportion``.</span>
<span class="sd">        3. For each cluster and feature, randomly mark the requested fraction of</span>
<span class="sd">           **observed** entries as validation targets.</span>
<span class="sd">        4. Create ``val_data`` (validation targets only) and training ``data`` where</span>
<span class="sd">           validation entries are set to NaN.</span>
<span class="sd">        5. Compute per-feature mean/std over non-NaN entries in ``data`` and apply</span>
<span class="sd">           normalization; then replace remaining NaNs with ``replacement_value``.</span>
<span class="sd">        </span>
<span class="sd">        :param data: Input matrix, shape ``(n_samples, n_features)``. May contain NaNs</span>
<span class="sd">        :type data: pandas.DataFrame or numpy.ndarray or torch.Tensor</span>
<span class="sd">        :param cluster_labels: Cluster assignment per sample (length ``n_samples``). If ``None``, all rows are assigned to a single cluster ``0``</span>
<span class="sd">        :type cluster_labels: array-like or None</span>
<span class="sd">        :param val_proportion: Per-cluster fraction of **non-missing** entries to hold out for validation, defaults to 0.1</span>
<span class="sd">        :type val_proportion: float or collections.abc.Sequence or collections.abc.Mapping or pandas.Series, optional</span>
<span class="sd">        :param replacement_value: Value to fill missing/held-out entries in ``self.data`` after masking, defaults to 0</span>
<span class="sd">        :type replacement_value: float, optional</span>
<span class="sd">        :param columns_ignore: Columns to exclude from validation masking (names for DataFrame, indices otherwise), defaults to None</span>
<span class="sd">        :type columns_ignore: list[str or int] or None, optional</span>
<span class="sd">        :param imputable: Optional Matrix showing which data entries to exclude from imputation (0 for impute, 1 for exclude from imputation), shape ``(n_samples, n_features)``. Should be same shape as ``data``. </span>
<span class="sd">        :type imputable: pandas.DataFrame | numpy.ndarray | torch.Tensor, optional</span>
<span class="sd">        :param val_seed: Optional (default 42), seed for random number generator for selecting validation dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## set seed for selecting valdata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">val_seed</span><span class="p">)</span>

        <span class="c1">## set columns ignore </span>
        <span class="k">if</span> <span class="n">columns_ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If columns_ignore is a pandas Index or Series, convert to list</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">columns_ignore</span><span class="p">,</span> <span class="s2">&quot;tolist&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span> <span class="o">=</span> <span class="n">columns_ignore</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">columns_ignore</span><span class="p">)</span>

        <span class="c1">## set to one cluster as default</span>

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Convert input data to numpy</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="c1">## Additions -&gt; check if the index column is non-numeric &amp;&amp; give error if there are other non-numeric columns</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;iloc&quot;</span><span class="p">):</span>  <span class="c1"># pandas DataFrame</span>
            <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>  <span class="c1"># safe for any index dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="c1"># Build ignore index list by name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignore_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span><span class="p">]</span>

            <span class="c1"># Build a numeric matrix column-by-column:</span>
            <span class="c1"># - ignored columns -&gt; float column filled with NaN (kept in shape, never used)</span>
            <span class="c1"># - non-ignored columns -&gt; must be numeric; error if not</span>
            <span class="n">converted_cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bad_cols</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_indices</span><span class="p">:</span>
                    <span class="c1"># If column is numeric, keep as-is; if not, replace with NaN float column</span>
                    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="n">converted_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">converted_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Must be numeric; coerce and detect non-numeric values (not counting real NaNs)</span>
                    <span class="n">sc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>
                    <span class="n">introduced_nonnumeric</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">s</span><span class="o">.</span><span class="n">isna</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">isna</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">introduced_nonnumeric</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">bad_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                    <span class="n">converted_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">bad_cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Non-numeric values found in columns not listed in columns_ignore: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bad_cols</span><span class="si">}</span><span class="s2">. Convert them to numeric or add them to `columns_ignore`.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Stack back to (n_rows, n_cols) float32</span>
            <span class="n">raw_data_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">converted_cols</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;V</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="c1"># Ensure numeric array</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ndarray input must be numeric. For mixed types, pass a DataFrame and use columns_ignore.&quot;</span><span class="p">)</span>
            <span class="n">raw_data_np</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># For ndarray, columns_ignore is by index only</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignore_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;V</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_complex</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="n">raw_data_np</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignore_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported data format. Must be DataFrame, ndarray, or Tensor.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">raw_data_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>


        <span class="c1"># --------------------</span>
        <span class="c1"># Added &#39;imputable&#39; matrix</span>
        <span class="c1"># --------------------</span>

        <span class="k">if</span> <span class="n">imputable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">imputable</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">):</span>  <span class="c1"># pandas DataFrame</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="o">=</span> <span class="n">imputable</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imputable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="o">=</span> <span class="n">imputable</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imputable</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="o">=</span> <span class="n">imputable</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported imputable matrix format. Must be DataFrame, ndarray, or Tensor.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imputable</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">expected_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># (n_samples, n_features)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`imputable` shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">imputable</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;data shape </span><span class="si">{</span><span class="n">expected_shape</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="n">dni_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dni_np</span> <span class="o">=</span> <span class="kc">None</span>
        

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Cluster labels to numpy</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="k">if</span> <span class="n">cluster_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create a LongTensor of zeros, one per sample</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
            <span class="n">cluster_labels_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">):</span>
                <span class="n">cluster_labels_np</span> <span class="o">=</span> <span class="n">cluster_labels</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">cluster_labels_np</span> <span class="o">=</span> <span class="n">cluster_labels</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">cluster_labels_np</span> <span class="o">=</span> <span class="n">cluster_labels</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported cluster_labels format. Must be Series, ndarray, or Tensor.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">cluster_labels_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels_np</span><span class="p">))</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels_np</span><span class="p">)</span>

        <span class="c1"># --------------------------</span>
        <span class="c1"># Resolve per-cluster validation proportion</span>
        <span class="c1"># --------------------------</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_as_per_cluster_props</span><span class="p">(</span><span class="n">vp</span><span class="p">):</span>
            <span class="c1"># scalar → broadcast</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`val_proportion` scalar must be in [0, 1].&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">}</span>

            <span class="c1"># pandas Series with labeled index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vp</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_clusters</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`val_proportion` Series missing clusters: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mapping</span>

            <span class="c1"># Mapping (e.g., dict)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vp</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_clusters</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`val_proportion` mapping missing clusters: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mapping</span>

            <span class="c1"># Sequence aligned to sorted unique clusters</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;`val_proportion` sequence length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="si">}</span><span class="s2">) must equal number of clusters (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">,</span> <span class="n">vals</span><span class="p">)}</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`val_proportion` must be float in [0,1], a sequence (len = #clusters), &quot;</span>
                <span class="s2">&quot;a pandas Series (index=cluster), or a mapping {cluster: proportion}.&quot;</span>
            <span class="p">)</span>

        <span class="n">per_cluster_prop</span> <span class="o">=</span> <span class="n">_as_per_cluster_props</span><span class="p">(</span><span class="n">val_proportion</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cid</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">per_cluster_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`val_proportion` for cluster </span><span class="si">{</span><span class="n">cid</span><span class="si">}</span><span class="s2"> must be in [0, 1]; got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Validation mask per cluster</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="n">val_mask_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">raw_data_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
            <span class="n">row_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels_np</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">row_idxs</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">raw_data_np</span><span class="p">[</span><span class="n">row_idxs</span><span class="p">]</span>      <span class="c1"># shape: (n_rows_in_cluster, n_features)</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="n">per_cluster_prop</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># nothing to select for this cluster</span>

            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cluster_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_indices</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># boolean masks (same length as row_idxs)</span>
                <span class="n">mask_non_missing</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">])</span>
                
                <span class="n">candidate_mask</span> <span class="o">=</span> <span class="n">mask_non_missing</span> 
                <span class="n">candidate_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">candidate_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># local indices within row_idxs</span>

                <span class="k">if</span> <span class="n">candidate_rows</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1">## Put back as floor but will mask at least one value if floor is 0</span>
                <span class="k">if</span> <span class="n">prop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">candidate_rows</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">prop</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="k">if</span> <span class="n">n_val</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">chosen_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">candidate_rows</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_val</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">val_mask_np</span><span class="p">[</span><span class="n">row_idxs</span><span class="p">[</span><span class="n">chosen_local</span><span class="p">],</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">val_mask_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">val_mask_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Set aside val_data</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_data</span><span class="p">[</span><span class="o">~</span><span class="n">val_mask_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># keep only validation-masked values</span>

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Combine true + validation-masked missingness</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">val_mask_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># mask validation entries</span>


        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Normalize non-missing entries</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="c1">## Compute mean and std on observed (non-NaN) entries</span>
        <span class="n">data_np</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">data_np</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">data_np</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">zero_std_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_stds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">zero_std_idx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bad_feats</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zero_std_idx</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[Warning] </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">zero_std_idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> feature(s) had zero std after masking. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Replaced with 1.0 to avoid div-by-zero. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Features: </span><span class="si">{</span><span class="n">bad_feats</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">feature_stds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_stds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># avoid division by zero</span>

        <span class="c1">## Normalize (in-place)</span>
        <span class="n">norm_data_np</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_np</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_means</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_stds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">norm_data_np</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># ----------------------------------------</span>
        <span class="c1"># Track missing &amp; replace with value</span>
        <span class="c1"># ----------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="o">~</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="c1">## true where value not na</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">replacement_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of samples in the dataset.</span>

<span class="sd">        :return: ``N`` (number of rows).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a single sample.</span>

<span class="sd">        :param index: Row index.</span>
<span class="sd">        :return: Tuple ``(x, cluster_id, mask, original_index)`` where:</span>
<span class="sd">            * **x** – normalized input row with NaNs replaced (``(P,)``).</span>
<span class="sd">            * **cluster_id** – integer cluster label (``()``).</span>
<span class="sd">            * **mask** – boolean mask of observed entries before replacement</span>
<span class="sd">            (``(P,)``).</span>
<span class="sd">            * **original_index** – original row index from the source DataFrame</span>
<span class="sd">            (if provided) or the integer position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>            <span class="c1"># input with missing replaced</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="c1"># cluster label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>          <span class="c1"># binary mask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>         <span class="c1"># original row index</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Displays the number of samples, features, and clusters, the percentage of missing data before masking, and the percentage of non-missing data held out for validation.</span>
<span class="sd">        </span>
<span class="sd">        :return: String representation of the dataset</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">total_values</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns_ignore</span><span class="p">))</span>

        <span class="c1">## Percent originally missing (before validation mask)</span>
        <span class="n">original_missing</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">original_missing_pct</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">original_missing</span> <span class="o">/</span> <span class="n">total_values</span>

        <span class="c1">## Percent used for validation (out of non-missing entries)</span>
        <span class="n">val_entries</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_data</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  <span class="c1"># number of validation-held entries</span>
        <span class="n">val_pct_of_nonmissing</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">val_entries</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_values</span> <span class="o">-</span> <span class="n">original_missing</span><span class="p">)</span>

        <span class="c1">## Count non-imputable entries (where can_impute == 0)</span>
        <span class="n">non_imputable_count</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;imputable&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">non_imputable_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">imputable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>        

        <span class="c1">## Build string</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;ClusterDataset(n_samples=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, n_features=</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">, n_clusters=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">))</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  • Original missing: </span><span class="si">{</span><span class="n">original_missing</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="n">total_values</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">original_missing_pct</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  • Validation held-out: </span><span class="si">{</span><span class="n">val_entries</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">val_pct_of_nonmissing</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% of non-missing)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  • .data shape:     </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  • .masks shape:    </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  • .val_data shape: </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">non_imputable_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  • Non-imputable entries: </span><span class="si">{</span><span class="n">non_imputable_count</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="c1"># ----------------------------------------</span>
    <span class="c1"># Added copy method</span>
    <span class="c1"># ----------------------------------------</span>
<div class="viewcode-block" id="ClusterDataset.copy">
<a class="viewcode-back" href="../../../_autosummary/ciss_vae.classes.cluster_dataset.ClusterDataset.html#ciss_vae.classes.cluster_dataset.ClusterDataset.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a deep copy of the ClusterDataset method containing all attributes.</span>
<span class="sd">        </span>
<span class="sd">        :return: Deep copy of the dataset</span>
<span class="sd">        :rtype: ClusterDataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Displays the number of samples, features, and clusters, the percentage of missing data before masking, and the percentage of non-missing data held out for validation.</span>
<span class="sd">        </span>
<span class="sd">        :return: String representation of the dataset</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span></div>



    


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Yasin Khadem Charvadeh, Danielle Vaithilingam, Kenneth Seier, Katherine S. Panageas, Mithat Gönen, Yuan Chen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>